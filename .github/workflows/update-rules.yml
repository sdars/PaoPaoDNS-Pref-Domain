name: Update Rules and Generate Config

on:
  schedule:
    # 每天运行三次（00:00, 08:00, 16:00 UTC）
    - cron: "0 0,8,16 * * *"
  workflow_dispatch: # 手动触发
  push: # 文件更新时触发
    paths:
      - 'rule/**' # 监控 rule 文件夹中的所有文件
      - 'config/**' # 监控 config 文件夹中的所有文件

jobs:
  update-rules:
    runs-on: ubuntu-latest

    steps:
      # 检出代码
      - name: Checkout code
        uses: actions/checkout@v3

      # 安装 yq 用于解析 YAML 文件
      - name: Install yq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.15.1/yq_linux_amd64 -O /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq

      # 读取配置文件并合并规则
      - name: Download and merge rules
        run: |
          # 读取 application.yml 中的规则和输出路径
          echo "Reading configuration from config/application.yml"

          # 使用 yq 获取配置，确保输出格式正确
          REMOTE_RULES=$(yq e '.rules.remote[]' config/application.yml)
          LOCAL_RULES=$(yq e '.rules.local[]' config/application.yml)
          OUTPUT_PATH=$(yq e '.output.path' config/application.yml)
          OUTPUT_FILE=$(yq e '.output.file' config/application.yml)

          # 输出配置值，帮助调试
          echo "REMOTE_RULES: $REMOTE_RULES"
          echo "LOCAL_RULES: $LOCAL_RULES"
          echo "OUTPUT_PATH: $OUTPUT_PATH"
          echo "OUTPUT_FILE: $OUTPUT_FILE"

          # 如果 OUTPUT_PATH 为空，设置默认路径
          if [ -z "$OUTPUT_PATH" ]; then
            OUTPUT_PATH="output"
            echo "OUTPUT_PATH is empty, using default: $OUTPUT_PATH"
          fi

          if [ -z "$OUTPUT_FILE" ]; then
            OUTPUT_FILE="knightdomain.txt"
            echo "OUTPUT_FILE is empty, using default: $OUTPUT_FILE"
          fi

          # 创建输出目录
          echo "Creating output directory: $OUTPUT_PATH"
          mkdir -p "$OUTPUT_PATH"

          # 下载远程规则并合并
          TEMP_FILE=$(mktemp)
          for url in $REMOTE_RULES; do
            echo "Downloading $url..."
            curl -s "$url" >> "$TEMP_FILE"
          done

          # 合并本地规则
          echo "Merging local rules..."
          for local_file in $LOCAL_RULES; do
            if [ -f "$local_file" ]; then
              cat "$local_file" >> "$TEMP_FILE"
            else
              echo "Local rule file not found: $local_file"
            fi
          done

          # 去除注释和重复项
          echo "Removing duplicates and comments..."
          grep -vE '^\s*#|^\s*$' "$TEMP_FILE" | sort -u > "$OUTPUT_PATH/$OUTPUT_FILE"

          # 清理临时文件
          rm -f "$TEMP_FILE"

          echo "Merged rules saved to $OUTPUT_PATH/$OUTPUT_FILE"

      # 检查输出目录及文件是否存在
      - name: Check output directory
        run: |
          echo "Checking if output directory exists: $OUTPUT_PATH"
          ls -ld "$OUTPUT_PATH"
          echo "Checking the content of the output directory:"
          ls -l "$OUTPUT_PATH"

      # 提交更改到 main 分支
      - name: Push changes to main branch
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # 拉取远程 main 分支的最新内容
          git pull origin main

          # 切换到 main 分支
          git checkout main

          # 检查文件是否存在并添加
          if [ -f "$OUTPUT_PATH/$OUTPUT_FILE" ]; then
            git add "$OUTPUT_PATH/$OUTPUT_FILE"
            git commit -m "Updated $OUTPUT_FILE at $(date +'%Y-%m-%d %H:%M:%S')" || echo "No changes to commit"
            git push origin main --force
          else
            echo "Output file not found: $OUTPUT_PATH/$OUTPUT_FILE"
          fi
